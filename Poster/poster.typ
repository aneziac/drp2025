#import "@local/superTemplate:0.3.0": *
#import "./template.typ": *
#import "@preview/cetz:0.3.0": canvas, draw
#import math_mod: *

#show: poster.with(
  "Basic Construction of Coxeter Groups",
  "Nate Annau and Jesse Cobb",
  "Benedict Lee",
  "University of California, Santa Barbara"
)

#set par(justify: true)
#set text(
  size: 24pt,
)
#show math.equation: set text(font: "New Computer Modern Math")

#let geom_pt(coords, label, fill_color, anchor) = {
  draw.circle(coords, radius: (0.05, 0.05), fill: fill_color)
  draw.content(coords, [#text(fill: fill_color)[#label]], anchor: anchor, padding: .1)
}

#let ccolor0 = rgb("#5D4C6D")
#let ccolor1 = rgb("#9E1758")
#let ccolor2 = rgb("#0A5053")
#let ccolor3 = rgb("#8B5407")

#let ccolor4 = rgb("#7E3263")
#let ccolor5 = rgb("#543456")
#let ccolor6 = rgb("#4B522D")
#let ccolor7 = rgb("#74503A")

#let cfill   = rgb("#97B6A1")


#let coxeter_systems = [
  *Dihedral groups*, well known from elementary group theory, encode the symmetries of regular polygons.
  For example, the square admits eight fundamental symmetries: reflections through its horizontal and vertical axes and two diagonals, and then rotations through 90, 180, and 270 degrees.

  #align(center + horizon)[
    #grid(
      columns: 2,
      gutter: 3em,
      canvas(length: 2.5cm, {
        import draw: *

        let (s0, s1, s2, s3) = ((0, 0), (1, 0), (1, 1), (0, 1))

        merge-path({
          line(s0, s1)
          line(s1, s2)
          line(s2, s3)
          line(s3, s0)
        })

        line((0.5, -0.25), (0.5, 1.25), stroke: (dash: "dashed"))
        line((-0.25, 0.5), (1.25, 0.5), stroke: (dash: "dashed"))
        line((-0.25, -0.25), (1.25, 1.25), stroke: (dash: "dashed"))
        line((-0.25, 1.25), (1.25, -0.25), stroke: (dash: "dashed"))
      }),
      [
        $D_4 = gen(r\, s | r^4 = s^2 = (s r)^2 = 1)$
      ]
    )
  ]

  Through the simple transformation $t := s r$, we can in fact view rotations as instances of reflections, which gives rise to the notion of a *geometric reflection group*#sym.dash.em a more generic group generated by reflections across a particular set of hyperplanes $cal(H)_i$ acting on Euclidean, hyperbolic, or spherical spaces.

  Abstracting this further, beyond purely geometric considerations, produces the *Coxeter group*, defined by the presentation
  $
    W = gen(s_1\, s_2\, dots\, s_n | (s_i s_j)^(m_(i j)) = 1)
  $
  where $m_(i i) = 1$ and $m_(i j) = m_(j i) in {2, 3, dots} union {infty}$ for all distinct $i, j$.
  Observe this definition implies each generator $s_i$ is an involution and thus corresponds to a reflection.

  Denoting the indexing set ${s_i}$ by $S$, we define a *Coxeter System* as the pair $(W, S)$.
]

#let tits_representation = [
  To better understand the abstract presentation of Coxeter groups, a key result due to Jacques Tits gives a faithful linear representation
  $
    rho : W -> GL_n (RR),
  $
  with $n = |S|$, such that
  - for each $i$, $rho(s_i) = sigma_i$ is a linear involution with fixed set a hyperplane
  - $forall i != j$, the product $sigma_i sigma_j$ has order $m_(i j)$

  To construct this, consider the real vector space $V$ with basis ${e_1, dots, e_n}$, and define a symmetric bilinear form $B$ on $V$ by
  $
    B(e_i, e_j) = cases(
      -cos(pi / m_(i j)) &"if" m_(i j) "is finite" \
      -1 &"if" m_(i j) = infty.
    )
  $
  Then for hyperplanes $H_i = {v in V : B (e_i, v) = 0}$, our linear maps $sigma_i : V -> V$ are defined by
  $
    sigma_i (v) = v - 2B(e_i, v) e_i,
  $
  which we note is the usual form of reflections in Euclidean geometry.
]

#let chambers_and_nerves = [
  Let $(W, S)$ be a Coxeter system. Let $
    W^((0))
      &= angle.l s_0, s_1, s_2, s_3 bar.v s_i^2 = (s_i s_(i + 1))^2 = 1, forall i in ZZ_4 angle.r \
    W^((1))
      &= angle.l s, t, u bar.v s^2 = t^2 = u^2 = 1, (s t)^3 angle.r iso D_6 * C_2.
  $
  #h(3cm)
  #grid(
    columns: 2,
    [
      - An *abstract simplicial complex* is a set $V$, called the _vertex set_, and a collection $X$ of finite subsets of $V$ such that (1) ${v} in X} forall v in V$; and (2) $Delta in X "and" Delta' subset.eq Delta ==> Delta' in X$
      - A *nerve* of a $(W, S)$, $L = L(W, S)$, is the simplicial complex with a simplex $sigma_T$ for each $T subset.eq S$ such that $T eq.not emptyset$ and $W_T$ is finite.
      - Let $L'$ be the *barycentric subdivision* of $L$.
      - The *chamber* $K$ is the cone on the $L'$. For each $s in S$ we can define the closed star in $L$ of the vertex $s$ to be $K_s subset.eq K$.
        - Since all simplices are represented by a nonempty set of generators, we let the point added when constructing the cone to be represented by the empty set, $emptyset$.
    ],
    gutter: 2em,
    align(center + horizon)[#grid(
      columns: 2,
      rows: 3,
      gutter: 1em,
      [$L(W^((0)))$#canvas(length: 2cm, {
        import draw: *
        let (s0, s1, s2, s3) = ((0, 0), (1, 0), (1, 1), (0, 1))

        merge-path(fill: none, {
          line(s0, s1)
          line(s1, s2)
          line(s2, s3)
          line(s3, s0)
        })

        geom_pt(s0, $s_0$, ccolor0, "north-east")
        geom_pt(s1, $s_1$, ccolor1, "north-west")
        geom_pt(s2, $s_2$, ccolor2, "south-west")
        geom_pt(s3, $s_3$, ccolor3, "south-east")
      })],
      [$L(W^((1)))$#canvas(length: 2cm, {
        import draw: *
        let val = calc.sqrt(3)/2
        let (s, t, u) = ((-1/2, val), (1/2, val), (0, 0))

        merge-path(fill: none, {
          line(s, t)
        })

        geom_pt(s, $s$, ccolor0, "south-east")
        geom_pt(t, $t$, ccolor1, "south-west")
        geom_pt(u, $u$, ccolor2, "north")
      })],
      [$L'(W^((0)))$#canvas(length: 2cm, {
        import draw: *
        let (s0, s1, s2, s3) = ((0, 0), (1, 0), (1, 1), (0, 1))
        let (s01, s12, s23, s30) = ((1/2, -1/2), (1 + 1/2, 1/2), (1/2, 1 + 1/2), (- 1/2, 1/2))

        merge-path(fill: none, {
          line(s0, s01)
          line(s01, s1)
          line(s1, s12)
          line(s12, s2)
          line(s2, s23)
          line(s23, s3)
          line(s30, s0)
        })

        geom_pt(s0, $s_0$, ccolor0, "north-east")
        geom_pt(s1, $s_1$, ccolor1, "north-west")
        geom_pt(s2, $s_2$, ccolor2, "south-west")
        geom_pt(s3, $s_3$, ccolor3, "south-east")

        geom_pt(s01, ${s_0, s_1}$, ccolor4, "north")
        geom_pt(s12, ${s_1, s_2}$, ccolor5, "west")
        geom_pt(s23, ${s_2, s_3}$, ccolor6, "south")
        geom_pt(s30, ${s_0, s_3}$, ccolor7, "east")
      })],
      [$L'(W^((0)))$#canvas(length: 2cm, {
        import draw: *
        let val = calc.sqrt(3)/2
        let (s, t, u) = ((-1/2, val), (1/2, val), (0, 0))
        let st = (0, 2 * val)

        merge-path(fill: none, {
          line(s, st)
          line(st, t)
        })

        geom_pt(s, $s$, ccolor0, "south-east")
        geom_pt(t, $t$, ccolor1, "south-west")
        geom_pt(u, $u$, ccolor2, "north")

        geom_pt(st, ${s, t}$, ccolor4, "south")
      })],
      [$K(W^((0)))$#canvas(length: 2cm, {
        import draw: *
        let (s0, s1, s2, s3) = ((0, 0), (1, 0), (1, 1), (0, 1))
        let (s01, s12, s23, s30) = ((1/2, -1/2), (1 + 1/2, 1/2), (1/2, 1 + 1/2), (- 1/2, 1/2))
        let eset = (1/2, 1/2)

        merge-path(fill: cfill, {
          line(s0, s01)
          line(s01, s1)
          line(s1, s12)
          line(s12, s2)
          line(s2, s23)
          line(s23, s3)
          line(s30, s0)
        })

        line(eset, s0)
        line(eset, s01)
        line(eset, s1)
        line(eset, s12)
        line(eset, s2)
        line(eset, s23)
        line(eset, s3)
        line(eset, s30)
        line(eset, s0)

        line(s30, s01, stroke: ccolor0 + 0.1em)
        line(s01, s12, stroke: ccolor1 + 0.1em)
        line(s12, s23, stroke: ccolor2 + 0.1em)
        line(s23, s30, stroke: ccolor3 + 0.1em)

        geom_pt(s0, $K_(s_0)$, ccolor0, "north-east")
        geom_pt(s1, $K_(s_1)$, ccolor1, "north-west")
        geom_pt(s2, $K_(s_2)$, ccolor2, "south-west")
        geom_pt(s3, $K_(s_3)$, ccolor3, "south-east")

        geom_pt(s01, [], black, "north")
        geom_pt(s12, [], black, "west")
        geom_pt(s23, [], black, "south")
        geom_pt(s30, [], black, "east")

        geom_pt(eset, $emptyset$, black, "north-west")
      })],
      [$K(W^((1)))$#canvas(length: 2cm, {
        import draw: *
        let val = calc.sqrt(3)/2
        let (s, t, u) = ((-1/2, val), (1/2, val), (0, 0))
        let st = (0, 2 * val)
        let eset = (0, val)

        merge-path(fill: cfill, {
          line(s, st)
          line(st, t)
          line(t, eset)
          line(eset, s)
        })

        line(eset, u)
        line(eset, st)

        line(s, st, stroke: ccolor0 + 0.1em)
        line(t, st, stroke: ccolor1 + 0.1em)

        geom_pt(s, $K_s$, ccolor0, "south-east")
        geom_pt(t, $K_t$, ccolor1, "south-west")
        geom_pt(u, $K_u$, ccolor2, "north")

        geom_pt(st, [], black, "south")
        geom_pt(eset, $emptyset$, black, "north-west")
      })],
    )]
  )
]

#let basic_construction = [
  To realize a Coxeter group, returning it to its geometric origins, we define its *basic construction* $cal(U)(W, X)$ as follows.

  If $(W, S)$ is a Coxeter system and $X$ connected and Hausdorff, define a *mirror structure* on $X$ over $S$ by a collection $(X_s)_(s in S)$ where each $X_s$ is a nonempty, closed subset of $X$.
  Call each $X_s$ the $s$-mirror of $X$.
  Our idea is to "glue" copies of $X$ along the mirrors.

  For each point $x in X$, define $S(x) subset.eq S$ by
  $
    S(x) := {s in S : x in X_s}.
  $

  Now consider some $T subset.eq S$.
  Define the *parabolic subgroup* $W_T$ of $W$ by $W_T = gen(T)$.
  We define a relation $sim$ on $W times X$ by
  $
    (w, x) sim (w', x') "if and only if" x = x' "and" inv(w) w' in W_(S(x)).
  $
  Now the *basic construction* is the quotient
  $
    cal(U)(W, X) = W times X \/ sim
  $
  equipped with the quotient topology.
]

#let Davis_complex_CAT0 = [
  #lorem(400)
]

#let acknowledgements = [
  #lorem(25)
]

#let references = [
  #lorem(25)
]

#pad(
  grid(
    columns: 3,
    inset: 0.5in,
    gutter: 30pt,
    [
      #poster_section("Coxeter Systems", coxeter_systems)
      #poster_section("Chambers and Nerves", chambers_and_nerves, fill: true)
    ],
    [
      #poster_section("Tits Representation", tits_representation, fill: true)
      #poster_section("Basic Construction", basic_construction)
    ],
    [
      #poster_section([The Davis Complex is $"CAT"(0)$], Davis_complex_CAT0, fill: true)
      #poster_section("Acknowledgements", acknowledgements)
      #poster_section("References", references, fill: true)
    ]
  ),
  top: 0.5in,
  x: 1in,
)

