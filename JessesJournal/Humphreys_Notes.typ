#import "@local/superTemplate:0.3.0": *
#import "@local/superTheorems:0.1.0": *
#import math_mod: *
#show: thmS-init.with(colors: "bootstrap")
#show: notes.with("Reflection Groups and Coxeter Groups - Humphreys", "Jesse Cobb")

= Finite Reflection Groups

== Reflections

#notn[
  $O(V)$ denotes the group of all orthogonal transformations of $V$
]

#rem[
  Each reflection $s_alpha$ in $W$ determines a reflecting hyperplane $H_alpha$ and a line $L_alpha = RR alpha$ which is orthogonal to it.
]

#prop[
  If $t in O(V)$ and $alpha$ is any nonzero vector in $V$, then $t s_alpha t^(-1) = s_(t alpha)$. In particular, if $w in W$, then $s_(w alpha)$ belongs to $W$ whenever $s_alpha$ does.
][]

== Roots

#defn(name: [Root System])[
  Let $Phi$ be a finite set of nonzero vectors in $V$ satisfying:
  1. $Phi cap RR alpha = {alpha, - alpha}$ for all $alpha in Phi$;
  2. $s_alpha Phi = Phi$ for all $alpha in Phi$.
  $Phi$ is called a *root system* and we let $W$ be the group generated by the reflections $s_alpha, alpha in Phi$.
]

#rem[
  Any finite reflection group can be realized in this way (as a result of a root system). Conversely, any group $W$ arising from a root system is finite.

  Given a root system $Phi$ and corresponding reflection group $W$, define $Phi'$ to be the set of unit vectors proportional to the vectors in $Phi$. Then $Phi'$ is a root sytem, with $W$ as corresponding reflection group.
]

== Positive and Simple Systems

#defn(name: [Total Ordering of Real Vector Space])[
  A *total ordering* of a real vector space $V$ is a transitive relation on $V$ ($<$) satisfying:
  1. For any $lambda, mu in V$ exactly one of $lambda < mu, lambda = mu, mu < lambda$ holds;
  2. For any $lambda, mu, nu in V$, if $mu < nu$ then $lambda + mu < lambda + nu$;
  3. If $mu < nu$ and $c$ is a nonzero real number, then $c mu < c nu$ if $c > 0$ while $c nu < c mu$ if $c < 0$.

  $lambda in V$ is *positive* if $0 < lambda$.

  #ex[
    Choose arbitrary ordered basis $lambda_1, ..., lambda_n$ of $V$. Then define $
      sum a_i lambda_i
        &< sum b_i lambda_i
    $ if $a_k < b_k$ where $k$ is the least index $i$ for which $a_i eq.not b_i$.
  ]
]

#defn(name: [Positive System])[
  For a root system $Phi$, a subset $Pi$ is a *positive system* if it consists of all those roots which are positive relative to some total ordering of $V$. We have that $- Pi$ is a *negative system*.

  #rem[
    Since roots come in pairs ${alpha, -alpha}$ we have that $Phi = Pi cup.sq (- Pi)$.
  ]
]

#defn(name: [Simple System])[
  A subset $Delta$ of a root system $Phi$ is a simple system if $Delta$ is a vector space basis for the $RR$-span of $Phi$ in $V$ and if moreover $alpha in Phi$ is a linear combination of $Delta$ with coefficients all of the same sign.

  The cardinality of a simple system is an invariant of $Phi$, since it measures the dimension of the span of $Phi$ in $V$. This is called the *rank* of $W$.
]

#thm[
  1. If $Delta$ is a simple system in $Phi$, then there is a unique positive system containing $Delta$.
  2. Every positive system $Pi$ in $Phi$ contains a unique simple system; in particular, simple systems exist.
][]

#cor[
  If $Delta$ is a simple system in $Phi$, then $(alpha, beta) lt.eq 0$ for all $alpha eq.not beta$ in $Delta$.
][]

== Conjugacy of Positive and Simple Systems

#rem[
  For any simple system $Delta$ and $w in W$ we have that $w Delta$ is a simple system with corresponding positive system $w Pi$.
]

#prop[
  Let $Delta$ be a simple system, contained in the positive system $Pi$. If $alpha in Delta$, then $s_alpha (Pi \\ {alpha}) = Pi \\ {alpha}$.
][]

#thm[
  Any two positive (resp. simple) systems in $Phi$ are conjugate under $W$.
][]

== Generation by Simple Reflections

#defn(name: [Height])[
  If $beta in Phi$ we can write $beta = sum_(alpha in Delta) c_alpha alpha$ uniquely. We call $sum c_alpha$ the *height* of $beta$ (relative to $Delta$) abbreviated $"ht"(beta)$.
]

#thm[
  For a fixed simple system $Delta$, $W$ is generated by the reflections $s_alpha (alpha in Delta)$.
][]

#cor[
  Given $Delta$, for every $beta in Phi$ there exists $w in W$ such that $w beta in Delta$.
][]

== The Length Function

#defn(name: [Length])[
  For any $w in W$ the *length* $ell(w)$ of $w$ (relative to $Delta$) is the smallest $r$ such that $
    w
      &= s_1 dots.h.c s_r
  $ where $s_i = s_(alpha_i)$ with $alpha_i in Delta$. The expression is called *reduced*. By convention we have $ell(1) = 0$.

  #rem[
    Note that $ell(w) = 1$ if and only if $w = s_alpha$ for some $alpha in Delta$. Also note that $ell(w) = ell(w^(-1))$ and since we have $det(s_alpha) = -1$ we have that $det(w) = (-1)^(ell(w))$. This implies that if $w$ is written as the product of $r$ reflections then $r$ and $ell(w)$ must have the same parity. Therefore $ell(s_alpha w) in {ell(w) + 1, ell(w) - 1}$.
  ]
]

#notn[
  For a fixed simple system $Delta$ and corresponding positive system $Pi$, define $
    n(w)
      &:= "Card"(Pi cap w^(-1) (- Pi))
      &= "number of positive roots sent to negative roots by" w.
  $

  Note we have $n(w^(-1)) = n(w)$.
]

#lem[
  Let $alpha in Delta, w in W$. Then:
  1. $w alpha > 0 ==> n(s_alpha w) = n(w) + 1$
  2. $w alpha < 0 ==> n(s_alpha w) = n(w) - 1$
  1. $w^(-1) alpha > 0 ==> n(w s_alpha) = n(w) + 1$
  2. $w^(-1) alpha < 0 ==> n(w s_alpha) = n(w) - 1$
][]

#cor[
  If $w in W$ is written as $w = s_1 dots.h.c s_r$, then $n(w) lt.eq r$. In particular, $n(w) lt.eq ell(w)$.
][]

== Deletion and Exchange Conditions

#thm[
  Fix a simple system $Delta$. Let $w = s_1 dots.h.c s_r$ be any expression of $w in W$ as a product of simple reflections ($s_i = s_(alpha_i)$ with repetitions permitted). Suppose $n(w) < r$. Then there exist indices $1 lt.eq i < j lt.eq r$ satisfying:
  1. $alpha_i = (s_(i + 1) dots.h.c s_(j - 1)) alpha_j$;
  2. $s_(i + 1) s_(i + 2) dots.h.c s_j = s_i s_(i + 1) dots.h.c s_(j - 1)$;
  3. $w = s_1 dots.h.c hat(s_i) dots.h.c hat(s_j) dots.h.c s_r$ where hat denotes omission (*deletion condition*).
][]

#cor[
  If $w in W$, then $n(w) = ell(w)$.
][]

#rem[
  Let $Pi(w) := Pi cap w^(-1) (- Pi)$ and let $
    beta_i
      &:= s_r s_(r - 1) dots.h.c s_(i + 1) (alpha_i), quad
    beta_r
      &:= alpha_r
  $ where $w = s_1 dots.h.c s_r$ is a reduced expression and $s_i = s_(alpha_i)$. Then $Pi(w) = {beta_1, ..., beta_r}$ where $beta_i$ is distinct.
]

#prop(name: [Exchange Condition])[
  Let $w = s_1 dots.h.c s_r$, where each $s_i$ is a simple reflection. If $ell(w s) < ell(w)$ for some simple reflection $s = s_alpha$, then there exists an index $i$ for which $w s = s_1 dots.h.c hat(s_i) dots.h.c s_r$. In particular, $w$ has a reduced expression ending in $s$ if and only if $ell(w s) < ell(w)$.
][]

== Simple Transitivity and the Longest Element

#thm[
  Let $Delta$ be a simple system, $Pi$ the corresponding positive system. The following conditions on $w in W$ are equivalent:
  1. $w Pi = Pi$;
  2. $w Delta = Delta$;
  3. $n(w) = 0$;
  4. $ell(w) = 0$;
  5. $w = 1$.
][]

== Generators and Relations

#notn[
  For any roots $alpha, beta$ we say $m(alpha, beta)$ is the order of $s_alpha s_beta$ in $W$.
]

#thm[
  Fix a simple system $Delta$ in $Phi$. Then $W$ is generated by the set $S := {s_alpha, alpha in Delta}$, subject only to the relations: $
    (s_alpha s_beta)^(m(alpha, beta))
      &= 1.
  $
][]

#defn(name: [Coxeter System])[
  The tuple $(W, S)$ is called a *Coxeter system* where $W$ is the group generated by the set $S$ and is therefore called a *Coxeter group*.

  It is required that $m(alpha, alpha) = 1$ but a relation $(s_alpha s_beta)^(m(alpha, beta)) = 1$ may be omitted to allow infinite order.
]

== Parabolic subgroups and Minimal Coset Representatives

#defn(name: [Parabolic Subgroup])[
  For a given simple system $Delta$ let $S$ be the set of simple reflections $s_alpha, alpha in Delta$. For any subset $I subset.eq S$ define $W_I$ to be the subgroup of $W$ generated by all $s_alpha in I$ and let $Delta_I := {alpha in Delta | s_alpha in I}$. $W_I$ is called a *parabolic subgroup*.

  Note that $Delta -> w Delta$ then we have $W_I -> w W_I w^(-1)$.
]

#prop[
  Fix a simple system $Delta$ and the corresponding set $S$ of simple reflections. Let $I subset.eq S$, and define $Phi_I$ to be the intersection of $Phi$ with the $RR$-span $V_I$ of $Delta_I$ in $V$.
  1. $Phi_I$ is a root system in $V$ (resp. $V_I$) with simplie system $Delta_I$ and with corresponding reflection group $W_I$ (resp $W_I$ restricted to $V_I$).
  2. Viewing $W_I$ as a reflection group, with length function $ell_I$ relative to the simple system $Delta_I$, we have $ell = ell_I$ on $W_I$.
  3. Define $W^I := {w in W | ell(w s) > ell(w) "for all" s in I}$. Given $w in W$, there is a unique $u in W^I$ and a unique $v in W_I$ such that $w = u v$. Their lengths satisfy $ell(w) = ell(u) + ell(v)$. Moreover, $u$ is the unique element of smallest length in the coset $w W_I$.
][]

#defn(name: [Minimal Coset Representatives])[
  The distinguished coset representatives $W^I$ may be called *minimal coset* representatives.
]

== Poincare Polynomials

#defn(name: [Poincare Polynomial])[
  Define the following sequence $
    a_n
      &:= "Card" {w in W | ell(w) = n}.
  $ Then define the polynomial $
    W(t)
      &:= sum_(n gt.eq 0) a_n t^n
      &= sum_(w in W) t^(ell(w)).
  $ $W(t)$ is called the *Poincare polynomial* of $W$.

  #ex[
    Let $W = S_3$ such that $W(t) = 1 + 2 t + 2 t^2 + t^3$.
  ]

  #rem[
    Note we have that $
      W(t)
        &= W_I (t) W^I (t).
    $ This can be used to derive $W(t)$ via an algorithm by induction on $|S|$.
  ]
]

#notn[
  Let $(-1)^I = (-1)^(|I|)$.
]

#prop[
  $
    sum_(I subset.eq S) (-1)^I (W(t))/(W_I (t))
      &= sum_(I subset.eq S) (-1)^I W^I (t)
      &= t^N
  $ where $N := |Pi|$ is the length of the longest element in $W$.
][]

== Fundamental Domains

#defn(name: [Fundamental Domain])[
  Let $Pi$ be a positive system and $H_alpha$ be a hyperplane with respect to some root $alpha$. There exists corresponding open half-spaces $A_alpha$ and $-A_alpha$ where $
    A_alpha
      &:= {lambda in V | (lambda, alpha) > 0}.
  $ Then define $
    C
      &:= cap.big_(alpha in Delta) A_alpha
  $ which is open and convex since $A_alpha$ is open and convex. Note $C$ is also a cone (closed under positive scalar multiples). Then let $D = clo(C)$ be the intersection of closed half-spaces $H_alpha cup A_alpha$. So $
    D
      &= {lambda in V | (lambda, alpha) gt.eq 0 "for all" alpha in Delta}.
  $ $D$ is a closed convex cone. $D$ is a *fundamental domain* for the action of $W$ on $V$, i.e., each $lambda in V$ is conjugate under $W$ to one and only one point in $D$.
]

#lem[
  Each $lambda in V$ is $W$-conjugate to some $mu in D$. Moreover, $mu - lambda$ is a nonnegative $RR$-linear combination of $Delta$.
][]

#defn(name: [Isotropy Group])[
  The *isotropy group* (or *stabilizer*) of an element $mu in V$ is defined by ${w in W | w mu = mu}$.
]

#thm[
  Fix $Pi supset.eq Delta$ (hence $D$), as above.
  1. If $w lambda = mu$ for $lambda, mu in D$, then $lambda = mu$ and $w$ is a product of simple reflections fixing $lambda$. In particular, if $lambda in C$, then the isotropy group of $lambda$ is trivial.
  2. $D$ is a fundamental domain for the action of $W$ on $V$.
  3. If $lambda in V$, the isotropy group of $lambda$ if generated by those reflections $s_alpha (alpha in Phi)$ which it contains.
  4. If $U$ is any subset of $V$, then the subgroup of $W$ fixing $U$ pointwise is generated by those reflections $s_alpha$ which it contains.
][]

#rem[
  $W$ exhibits a simply transitive action on a family of open sets. This family is the connected components of the complement in $V$ of $cup.big_alpha H_alpha$ and are called *chambers*.

  Given a chamber $C$ corresponding to a simple system $Delta$, its *walls* are defined to be the hyperplanes $H_alpha (alpha in Delta)$. Each wall has a 'positive' or 'negative' side (with $C$ lying on the positive side). Then the roots in $Delta$ can be characterized as those roots which are orthogonal to some wall of $C$ and positively directed.
]

== The Latiice of Parabolic Subgroups

#prop[
  Under the correspondence $I |-> W_I$, the collection of parabolic subgroups $W_I (I subset.eq S)$ is isomorphic to the lattice of subsets of $S$.
][]

== Reflections in $W$

#prop[
  Every reflection in $W$ is of the form $s_alpha$ for some $alpha in Phi$.
][]

== The Coxeter Complex

#defn(name: [Coxeter Complex])[
  Fix a simple system $Delta$ and the corresponding set $S$ of simple reflections. For any subset $I$ of $S$ define $
    C_I
      &= {lambda in D | (lambda, alpha) = 0 "for all" alpha in Delta_I, (lambda, alpha) > 0 "for all" alpha in Delta \\ Delta_I}
  $ where $D$ is a fundamental domain. The sets $C_I$ partition $D$, with $C_emptyset = C$ and $C_S = {0}$. $V$ is partitioned by $cal(C) = w C_I (w in W, I subset.eq S)$. $w C_I$ and $w' C_I$ are disjoint unless $w$ and $w'$ lie in the same left coset in $W \/ W_I$ in which case they are equal. For distinct $I$ and $J$ we have $w C_I$ and $w' C_J$ are always disjoint. We call $cal(C)$ the *Coxeter complex* of $W$. Any set $w C_I$ is called a *facet* of type $I$.
]

#prop[
  For each $I subset.eq S$, the isotropy group of the facet $C_I$ of $cal(C)$ is precisely $W_I$. Thus the parabolic subgroups of $W$ are the isotropy groups of the elements of $cal(C)$.
][]

#rem[
  Note you can interpret $cal(C)$ as an abstract simplicial complex where the vertices are the left cosets $w W_I$, where $I$ is maximal in $S$. A finite set of vertices determines a 'simplex' if these vertices have a nonempty intersection.
]

== An Alternating Sum Formula

#note[
  Let $H_1, ..., H_r$ be an arbitrary collection of hyperplanes in $V$ (dimension $n$). Each hyperplane $H = H^0$ defines a positive half-space $H^+$ and a negative half-space $H^-$. An element of the complex $cal(K)$ is a nonempty intersection of the form $
    K
      &= cap.big H_i^(epsilon_i), quad
      &epsilon_i in {0, +, -}.
  $ $dim K = i$ if the linear span has dimension $i$, where the linear span $L$ is the intersection of all $H_i^0$ which occur in the definition of $K$.
]

#lem[
  Denote by $n_i$ the number of elements of $cal(K)$ having dimension $i$. Then $
    sum_i (-1)^i n_i
      &= (-1)^n.
  $
][]

#prop[
  $
    sum_(I subset.eq S) (-1)^I f_I (w)
      &= det(w).
  $
][]

= Classification of Finite Reflection Groups

== Isomorphisms

#defn(name: [Coxeter Graph])[
  For a Coxeter group $W$ generated by a simple system $Delta$, let $Gamma$ be a graph with vertex set $V iso Delta$. Edges are given for roots $alpha eq.not beta$ where $m(alpha, beta) gt.eq 3$ labeled with $m(alpha, beta)$. Note since simple systems are conjugate, $Gamma$ does not depend on the choice $Delta$.

  #ex[
    For the dihedral group $W = D_m$ we have

    #diagram({
      let (A, B) = ((0, 0), (1, 0))
      node(A, "", stroke: 0.5pt, radius: 0.2em)
      node(B, "", stroke: 0.5pt, radius: 0.2em)
      edge(A, B, "-", label: $m$)
    })

    For $W = S_(n + 1)$ then with $n$ vertices we have

    #diagram(node-stroke: 0.5pt, {
      let (A, B, Y, Z) = ((0, 0), (1, 0), (3, 0), (4, 0))
      node(A, "", radius: 0.2em)
      node(B, "", radius: 0.2em)
      node(Y, "", radius: 0.2em)
      node(Z, "", radius: 0.2em)
      edge(A, B, "-", label: $3$)
      edge(B, Y, "dotted")
      edge(Y, Z, "-", label: $3$)
    })
  ]
]

#prop[
  For $i = 1, 2$ let $W_i$ be a finite reflection group acting on the euclidean space $V_i$. Assume $W_i$ is essential. If $W_1$ and $W_2$ have the same Coxeter graph, then there is an isometry of $V_1$ onto $V_2$ inducing an isomorphism of $W_1$ onto $W_2$. (In particular, if $V_1 = V_2$, the subgroups $W_1$ and $W_2$ are conjugate in $O(V)$.)
][]

== Irreducible Components

#defn(name: [Irreducible])[
  A Coxeter system $(W, S)$ is *irreducible* if the Coxeter graph $Gamma$ is connected ($Phi$ is also called irreducible in this case).
]

#prop[
  Let $(W, S)$ have Coxeter graph $Gamma$, with connected components $Gamma_1, ..., Gamma_r$, and let $S_1, ..., S_r$ be the corresponding subsets of $S$. Then $W$ is the direct product of the parabolic subgroups $W_(S_1), ..., W_(S_r)$, and each Coxeter system $(W_(S_i), S_i)$ is irreducible.
][]

== Coxeter Graphs and Associated Bilinear Forms

#rem[
  We associate to a Coxeter graph $Gamma$ with vertex set $S$ of cardinality $n$ a symmetric $n times n$ matrix $A$ by setting $a(s, s') := - cos(pi/(m(s, s')))$. This defines a bilinear form $x^t A y$ for any $x, y in RR^n$.

  We call $Gamma$ positive definite or positive semidefinite when $A$ has the corresponding property. Also note that $A$ is positive definite (resp. semidefinite) if and only if all its principala minors are positive (resp. nonnegative).

  When $Gamma$ is derived from a finite reflection group $W$, the matrix $A$ is positive definite since it represents the standard euclidean inner product relative to the basis $Delta$ of $V$.
]

== Some Positive Definite Graphs

#note[
  #align(center)[#table(
    columns: (auto, auto),
    rows: 5em,
    align: horizon + left,
    //stroke: none,
    $A_n (n gt.eq 1)$,
    diagram(node-stroke: 0.5pt, {
      let (A, B, C, X, Y, Z) = ((0, 0), (1, 0), (2, 0), (4, 0), (5, 0), (6, 0))
      node(A, "", radius: 0.2em)
      node(B, "", radius: 0.2em)
      node(C, "", radius: 0.2em)
      node(X, "", radius: 0.2em)
      node(Y, "", radius: 0.2em)
      node(Z, "", radius: 0.2em)
      edge(A, B, "-")
      edge(B, C, "-")
      edge(C, X, "dotted")
      edge(X, Y, "-")
      edge(Y, Z, "-")
    }),

    $B_n (n gt.eq 2)$,
    diagram(node-stroke: 0.5pt, {
      let (A, B, C, X, Y, Z) = ((0, 0), (1, 0), (2, 0), (4, 0), (5, 0), (6, 0))
      node(A, "", radius: 0.2em)
      node(B, "", radius: 0.2em)
      node(C, "", radius: 0.2em)
      node(X, "", radius: 0.2em)
      node(Y, "", radius: 0.2em)
      node(Z, "", radius: 0.2em)
      edge(A, B, "-")
      edge(B, C, "-")
      edge(C, X, "dotted")
      edge(X, Y, "-")
      edge(Y, Z, "-", label: $4$)
    }),

    $D_n (n gt.eq 4)$,
    diagram(node-stroke: 0.5pt, {
      let (A, B, C, X, Y, Z1, Z2) = ((0, 0), (1, 0), (2, 0), (4, 0), (5, 0), (6, .5), (6, -.5))
      node(A, "", radius: 0.2em)
      node(B, "", radius: 0.2em)
      node(C, "", radius: 0.2em)
      node(X, "", radius: 0.2em)
      node(Y, "", radius: 0.2em)
      node(Z1, "", radius: 0.2em)
      node(Z2, "", radius: 0.2em)
      edge(A, B, "-")
      edge(B, C, "-")
      edge(C, X, "dotted")
      edge(X, Y, "-")
      edge(Y, Z1, "-")
      edge(Y, Z2, "-")
    }),

    $E_6$,
    diagram(node-stroke: 0.5pt, {
      let (A, B, C, D, E) = ((0, 0), (1, 0), (2, 0), (3, 0), (4, 0))
      let Z = (2, -1)
      node(A, "", radius: 0.2em)
      node(B, "", radius: 0.2em)
      node(C, "", radius: 0.2em)
      node(D, "", radius: 0.2em)
      node(E, "", radius: 0.2em)
      node(Z, "", radius: 0.2em)
      edge(A, B, "-")
      edge(B, C, "-")
      edge(C, D, "-")
      edge(D, E, "-")

      edge(C, Z, "-")
    }),

    $E_7$,
    diagram(node-stroke: 0.5pt, {
      let (A, B, C, D, E, F) = ((0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (5, 0))
      let Z = (2, -1)
      node(A, "", radius: 0.2em)
      node(B, "", radius: 0.2em)
      node(C, "", radius: 0.2em)
      node(D, "", radius: 0.2em)
      node(E, "", radius: 0.2em)
      node(F, "", radius: 0.2em)
      node(Z, "", radius: 0.2em)
      edge(A, B, "-")
      edge(B, C, "-")
      edge(C, D, "-")
      edge(D, E, "-")
      edge(E, F, "-")

      edge(C, Z, "-")
    }),

    $E_8$,
    diagram(node-stroke: 0.5pt, {
      let (A, B, C, D, E, F, G) = ((0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0))
      let Z = (2, -1)
      node(A, "", radius: 0.2em)
      node(B, "", radius: 0.2em)
      node(C, "", radius: 0.2em)
      node(D, "", radius: 0.2em)
      node(E, "", radius: 0.2em)
      node(F, "", radius: 0.2em)
      node(G, "", radius: 0.2em)
      node(Z, "", radius: 0.2em)
      edge(A, B, "-")
      edge(B, C, "-")
      edge(C, D, "-")
      edge(D, E, "-")
      edge(E, F, "-")
      edge(F, G, "-")

      edge(C, Z, "-")
    }),

    $F_4$,
    diagram(node-stroke: 0.5pt, {
      let (A, B, C, D) = ((0, 0), (1, 0), (2, 0), (3, 0))
      node(A, "", radius: 0.2em)
      node(B, "", radius: 0.2em)
      node(C, "", radius: 0.2em)
      node(D, "", radius: 0.2em)
      edge(A, B, "-")
      edge(B, C, "-", label: $4$)
      edge(C, D, "-")
    }),

    $H_3$,
    diagram(node-stroke: 0.5pt, {
      let (A, B, C) = ((0, 0), (1, 0), (2, 0))
      node(A, "", radius: 0.2em)
      node(B, "", radius: 0.2em)
      node(C, "", radius: 0.2em)
      edge(A, B, "-", label: $5$)
      edge(B, C, "-")
    }),

    $H_4$,
    diagram(node-stroke: 0.5pt, {
      let (A, B, C, D) = ((0, 0), (1, 0), (2, 0), (3, 0))
      node(A, "", radius: 0.2em)
      node(B, "", radius: 0.2em)
      node(C, "", radius: 0.2em)
      node(D, "", radius: 0.2em)
      edge(A, B, "-", label: $5$)
      edge(B, C, "-")
      edge(C, D, "-")
    }),

    $I_2 (m)$,
    diagram(node-stroke: 0.5pt, {
      let (A, B) = ((0, 0), (1, 0))
      node(A, "", radius: 0.2em)
      node(B, "", radius: 0.2em)
      edge(A, B, "-", label: $m$)
    })
  )]
]

== Some Positive Semidefinite Graphs

#note[
  #align(center)[#table(
    columns: (auto, auto),
    rows: 5em,
    align: horizon + left,
    //stroke: none,
    $tilde(A_1)$,
    diagram(node-stroke: 0.5pt, {
      let (A, B) = ((0, 0), (1, 0))
      node(A, "", radius: 0.2em)
      node(B, "", radius: 0.2em)
      edge(A, B, "-", label: $infty$)
    }),

    $tilde(A_n) (n gt.eq 2)$,
    diagram(node-stroke: 0.5pt, {
      let (A, B, Q, X, Y) = ((0, 0), (1, 0), (2, -1), (3, 0), (4, 0))
      node(A, "", radius: 0.2em)
      node(B, "", radius: 0.2em)
      node(Q, "", radius: 0.2em)
      node(X, "", radius: 0.2em)
      node(Y, "", radius: 0.2em)
      edge(A, B, "-")
      edge(A, Q, "-")
      edge(Y, Q, "-")
      edge(X, Y, "-")
      edge(B, X, "dotted")
    }),

    $tilde(B_2) = tilde(C_2)$,
    diagram(node-stroke: 0.5pt, {
      let (A, B, C) = ((0, 0), (1, 0), (2, 0))
      node(A, "", radius: 0.2em)
      node(B, "", radius: 0.2em)
      node(C, "", radius: 0.2em)
      edge(A, B, "-", label: $4$)
      edge(B, C, "-", label: $4$)
    }),

    $tilde(B_n) (n gt.eq 3)$,
    diagram(node-stroke: 0.5pt, {
      let (A1, A2, B, C, X, Y, Z) = ((0, -.5), (0, .5), (1, 0), (2, 0), (4, 0), (5, 0), (6, 0))
      node(A1, "", radius: 0.2em)
      node(A2, "", radius: 0.2em)
      node(B, "", radius: 0.2em)
      node(C, "", radius: 0.2em)
      node(X, "", radius: 0.2em)
      node(Y, "", radius: 0.2em)
      node(Z, "", radius: 0.2em)
      edge(A1, B, "-")
      edge(A2, B, "-")
      edge(B, C, "-")
      edge(C, X, "dotted")
      edge(X, Y, "-")
      edge(Y, Z, "-", label: $4$)
    }),

    $tilde(C_n) (n gt.eq 3)$,
    diagram(node-stroke: 0.5pt, {
      let (A, B, C, X, Y, Z) = ((0, 0), (1, 0), (2, 0), (4, 0), (5, 0), (6, 0))
      node(A, "", radius: 0.2em)
      node(B, "", radius: 0.2em)
      node(C, "", radius: 0.2em)
      node(X, "", radius: 0.2em)
      node(Y, "", radius: 0.2em)
      node(Z, "", radius: 0.2em)
      edge(A, B, "-", label: $4$)
      edge(B, C, "-")
      edge(C, X, "dotted")
      edge(X, Y, "-")
      edge(Y, Z, "-", label: $4$)
    }),


    $tilde(D_n) (n gt.eq 4)$,
    diagram(node-stroke: 0.5pt, {
      let (A1, A2, B, C, X, Y, Z1, Z2) = ((0, -.5), (0, .5), (1, 0), (2, 0), (4, 0), (5, 0), (6, .5), (6, -.5))
      node(A1, "", radius: 0.2em)
      node(A2, "", radius: 0.2em)
      node(B, "", radius: 0.2em)
      node(C, "", radius: 0.2em)
      node(X, "", radius: 0.2em)
      node(Y, "", radius: 0.2em)
      node(Z1, "", radius: 0.2em)
      node(Z2, "", radius: 0.2em)
      edge(A1, B, "-")
      edge(A2, B, "-")
      edge(B, C, "-")
      edge(C, X, "dotted")
      edge(X, Y, "-")
      edge(Y, Z1)
      edge(Y, Z2)
    }),

    $tilde(E_6)$,
    diagram(node-stroke: 0.5pt, {
      let (A, B, C, D, E, F) = ((0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (5, 0))
      let (Y, Z) = ((2, -1), (3, -1))
      node(A, "", radius: 0.2em)
      node(B, "", radius: 0.2em)
      node(C, "", radius: 0.2em)
      node(D, "", radius: 0.2em)
      node(E, "", radius: 0.2em)
      node(F, "", radius: 0.2em)
      node(Y, "", radius: 0.2em)
      node(Z, "", radius: 0.2em)
      edge(A, B, "-")
      edge(B, C, "-")
      edge(C, D, "-")
      edge(D, E, "-")
      edge(E, F, "-")

      edge(C, Y, "-")
      edge(Y, Z, "-")
    }),

    $tilde(E_7)$,
    diagram(node-stroke: 0.5pt, {
      let (A, B, C, D, E, F, G, H) = ((0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0), (7, 0))
      let Z = (3, -1)
      node(A, "", radius: 0.2em)
      node(B, "", radius: 0.2em)
      node(C, "", radius: 0.2em)
      node(D, "", radius: 0.2em)
      node(E, "", radius: 0.2em)
      node(F, "", radius: 0.2em)
      node(G, "", radius: 0.2em)
      node(H, "", radius: 0.2em)
      node(Z, "", radius: 0.2em)
      edge(A, B, "-")
      edge(B, C, "-")
      edge(C, D, "-")
      edge(D, E, "-")
      edge(E, F, "-")
      edge(F, G, "-")
      edge(G, H, "-")

      edge(D, Z, "-")
    }),

    $tilde(E_8)$,
    diagram(node-stroke: 0.5pt, {
      let (A, B, C, D, E, F, G, H) = ((0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0), (7, 0))
      let Z = (2, -1)
      node(A, "", radius: 0.2em)
      node(B, "", radius: 0.2em)
      node(C, "", radius: 0.2em)
      node(D, "", radius: 0.2em)
      node(E, "", radius: 0.2em)
      node(F, "", radius: 0.2em)
      node(G, "", radius: 0.2em)
      node(H, "", radius: 0.2em)
      node(Z, "", radius: 0.2em)
      edge(A, B, "-")
      edge(B, C, "-")
      edge(C, D, "-")
      edge(D, E, "-")
      edge(E, F, "-")
      edge(F, G, "-")
      edge(G, H, "-")

      edge(C, Z, "-")
    }),

    $tilde(F_4)$,
    diagram(node-stroke: 0.5pt, {
      let (A, B, C, D, E) = ((0, 0), (1, 0), (2, 0), (3, 0), (4, 0))
      node(A, "", radius: 0.2em)
      node(B, "", radius: 0.2em)
      node(C, "", radius: 0.2em)
      node(D, "", radius: 0.2em)
      node(E, "", radius: 0.2em)
      edge(A, B, "-")
      edge(B, C, "-")
      edge(C, D, "-", label: $4$)
      edge(D, E, "-")
    }),

    $tilde(G_2)$,
    diagram(node-stroke: 0.5pt, {
      let (A, B, C) = ((0, 0), (1, 0), (2, 0))
      node(A, "", radius: 0.2em)
      node(B, "", radius: 0.2em)
      node(C, "", radius: 0.2em)
      edge(A, B, "-")
      edge(B, C, "-", label: $6$)
    }),
  )]
]

== Subgraphs

#defn(name: [Subgraph])[
  A subgraph of a Coxeter graph $Gamma$ is a graph with some vertices omitted, some of the edges label's decremented, or both.
]

#defn(name: [Indecomposable])[
  A real $n times n$ matrix $A$ is *indecomposable* if there is no partition on the index set into nonempty subsets $I, J$ such that $a_(i j) = 0$ whenever $i in I, j in J$.

  #rem[
    Coxeter graph is indecomposable precisely when the graph is connected.
  ]
]

#prop[
  Let $A$ be a real symmetric $n times n$ matrix which is positive semidefinite and indecomposable (in particular, the eigenvalues of $A$ are real and nonnegative). Assume $a_(i j) lt.eq 0$ whenever $i eq.not j$. Then:
  1. $N := {x in RR^n | x^t A x = 0}$ coincides with the nullspace of $A$ and has dimension $lt.eq 1$.
  2. The smallest eigenvalue of $A$ has multiplicity $1$, and has an eigenvector whose coordinates are strictly positive.
][]

#cor[
  If $Gamma$ is a connected Coxeter graph of positive type, then every (proper) subgraph is positive definite.
][]

== Classification of Graphs of Positive Type

#thm[
  The previous positive definite and positive semidefinite graphs are the only connected Coxeter graphs of positive type.
][]

== Crystallographic Groups

#defn(name: [Crystallographic Group])[
  A subgroup $G$ of $GL (V)$ is crystallographic if it stabilizes a lattice in $V$ (the $ZZ$-span of a basis of $V$): $g L subset.eq L$ for all $g in G$.
]

#prop[
  If $W$ is crystallographic, then each integer $m(alpha, beta)$ must be $2$, $3$, $4$, or $6$ when $alpha eq.not beta$ in $Delta$.
][]

#rem[
  Note this implies groups of type $H_3$ and $H_4$ as well of $D_n$ for $n = 2, 4, 6, 8, 12$ are not crystallographic.
]

== Crystallographic Root Systems and Weyl Groups

#defn(name: [Weyl Group])[
  A root system $Phi$ is *crystallographic* if it satisfies the additional requirement: $
    (2 (alpha, beta))/(beta, beta) in ZZ, forall alpha, beta in Phi.
  $ These integers are called *Cartan integers*. The group $W$ generated by all reflections $s_alpha (alpha in Phi)$ is known as the *Weyl group* of $Phi$.

  This requirement ensures all roots are $ZZ$-linear combinations of $Delta$, and that the $ZZ$-span of $Delta$ in $V$ is a $W$-stable lattice.
]

#defn(name: [Dual Root System])[
  Let $a^or := 2 alpha\/(alpha, alpha)$ and let $Phi^or$ of all *coroots* $alpha^or (alpha in Phi)$. $Phi^or$ is also a crystallographic root system in $V$, with simple system $Delta^or := {alpha^or | alpha in Delta}$. This is also called the inverse or dual root system.

  Short roots $alpha$ in a system $Phi$ of type $B_n$ give rise to long roots $alpha^or$ in the system $Phi^or$ of type $C_n$ (and vice versa).
]

#defn(name: [Root Lattice])[
  For a root system $Phi$ in $V$ the $ZZ$-span $L(Phi)$ is called the *root lattice*. The *coroot lattice* is defined as $L(Phi^or)$. Both are $W$-stable.

  The *weight lattice* and *coweight lattice* are defined as $
    hat(L) (Phi)
      &:= {lambda in V | (lambda, alpha^or) in ZZ, forall alpha in Phi} \
    hat(L) (Phi^or)
      &:= {lambda in V | (lambda, alpha) in ZZ, forall alpha in Phi} \
  $

  #rem[
    $hat(L) (Phi)$ is a subgroup of $L(Phi)$ with finite index $f$ and similarly $hat(L) (Phi^or)$ is a subgroup of $L(Phi^or)$. Where $f$ is the determinant of the matrix of Cartan integers $(alpha, beta^or)$ for any $alpha, beta in Delta$. $f$ is also called the *index of connection* in Lie theory.

    $hat(L) \/ L$ is isomorphic to the fundamental group of a compact Lie group of adjoint type having $W$ as Weyl group.
  ]
]

#rem[
  A partial ordering on $V$ (if $Delta$ is fixed) exists: $mu lt.eq lambda$ if and only if $lambda - mu$ is a nonnegative $ZZ$-linear combination of $Delta$.

  If $Phi$ is irreducible then there exists a unique highest long root $tilde(alpha)$ and unique highest short root.
]

== Construction of Root Systems

#note[
  ($A_n, n gt.eq 1$) Let $V$ be a hyperplan in $RR^(n + 1)$ consisting of vectors whose coordinates add up to $0$. $Phi$ is the set ${epsilon_i - epsilon_j | 1 lt.eq i eq.not j lt.eq n + 1}$ and $Delta = {epsilon_1 - epsilon_2, epsilon_2 - epsilon_3, ..., epsilon_n - epsilon_(n + 1)}$. Then $tilde(alpha) = epsilon_1 - epsilon_(n + 1)$. $W$ is $S_(n + 1)$ which acts by permutting $epsilon_i$.
]

== Computing the Order of $W$

#note[
  Long roots form a single $W$-orbit (when $W$ is irreducible). $(tilde(alpha), alpha) gt.eq 0$ for any $alpha in Delta$ thus $tilde(alpha)$ lies in the fundamental domain $D$. This gives an inductive method for calculating $ord(W)$ via the Orbit-Stabilizer theorem.
]

== Exceptional Weyl Groups

#note[
  $F_4$ is the group of symmetries of a regular solid in $RR^4$ having $24$ faces which are octahedra.

  $E_6$ is the group of automorphisms of the configuration of $27$ lines on a cubic surface.

  $E_7$ has the following interesting properties: $L(Phi) \/ 2 L(Phi)$ is a seven-dimensional vector space of $FF_2$, $L(Phi) \/ 2 hat(L) (Phi)$ is a six-dimensional vector space over $F_2$. Both have interesting inner product relations.

  $E_8$ has $L(Phi) \/ 2 L(Phi)$ is an eight-dimensional vector space over $FF_2$. The inner product has interesting properties as well.
]

== Groups of Types $H_3$ and $H_4$

#note[
  $H_3$ is the symmetry group of the icosahedron (20 triangular faces) in $RR^3$ (order of $120$)

  $H_4$ is the symmetry group of a regular $120$-sided solid (with dodecadegral faces) in $RR^4$ (order of $14400$).
]

#lem[
  Any finite subgroup $G$ of even order in $HH$ is a root system (when regarded as a subset of $RR^4$).
][]

= Polynomial Invariants of Finite Reflection Groups

= Affine Reflection Groups

== Affine Reflections

#defn(name: [Affine Reflection])[
  The *affine group* of $V$, denoted $"Aff"(V)$, is the semidirect product of $GL(V)$ and the group of translations by elements of $V$. $
    g t(lambda) g^(-1)
      &= t(g lambda)
  $ for any $g in GL(V)$, $lambda in V$, and $t$ any translation. This shows the group of translations is normalized by $GL(V)$.

  Define the affine hyperplane for a root $alpha$ and integer $k$ $
    H_(alpha, k)
      &= {lambda in V | (lambda, alpha) = k}.
  $ $H_(alpha, k)$ can be attained by translating the hyperplane $H_alpha$ by $k/2 alpha^or$. Define $cal(H)$ to be the collection of $H_(alpha, k)$ for any $alpha in Phi, k in ZZ$.

  Define the *affine reflection* as $
    s_(alpha, k) (lambda)
      &:= lambda - ((lambda, alpha) - k) alpha^or.
  $ Note that $s_(alpha, k) = t(k alpha^or) s_alpha$.
]

#prop[
  1. If $w in W$, then $w H_(alpha, k) = H_(w alpha, k)$ and $w s_(alpha, k) w^(-1) = s_(w alpha, k)$.
  2. If $lambda in V$ satisfies $(lambda, alpha) in ZZ$ for all roots $alpha$, then $t(lambda) H_(alpha, k) = H_(alpha, k + (lambda, alpha))$ and $t(lambda) s_(alpha, k) t(-lambda) = s_(alpha, k + (lambda, alpha))$.
][]

== Affine Weyl Groups

#defn(name: [Affine Weyl group])[
  Define the *affine Weyl group* $W_a$ to be the subgroup of $"Aff"(V)$ generated by all affine reflections $s_(alpha, k)$, where $alpha in Phi, k in ZZ$.
]

#ex(name: [Infinite Dihedral group])[
  The infinite dihedral group is the affine reflection group generated by $s_(alpha, 0) = s_alpha$ and $s_(alpha, 1)$.
]

#prop[
  $W_a$ is the semidirect product of $W$ and the translation group corresponding to the coroot lattice $L = L(Phi^or)$.
][]

#rem[
  $W$ also normalizes $hat(L) (Phi^or)$ such that we can define a semidirect product $hat(W_a)$ that contains $W_a$ as a normal subgroup of finite index. $hat(W_a) \/ W_a$ is isomorphic to $hat(L) \/ L$.
]

#cor[
  If $w in hat(W_a)$ and $H_(alpha, k) in cal(H)$, then $w H_(alpha, k) = H_(beta, l)$ for some $beta in Phi, l in ZZ$, and thus $w s_(alpha, k) w^(-1) = s_(beta, l)$.
][]

== Alcoves

#defn(name: [Alcoves])[
  We define $V^circle.small = V \/ cup.big_(H in cal(H)) H$. The connected components in $V^circle.small$, $cal(A)$, are called *alcoves*. $hat(W_a)$ permutes $cal(A)$.

  A specific alcove is of interest when $Phi$ is irreducible $
    A_circle.small
      &= {lambda in V | 0 < ip(lambda, alpha) < 1 "for all" alpha in Phi^+} \
      &= {lambda in V | 0 < ip(lambda, alpha) "for all" alpha in Delta, ip(lambda, tilde(alpha)) < 1}
  $ for a unique highest root such that $tilde(alpha) - alpha$ is a sum of simple roots. The walls of $A_circle.small$ are given by $H_alpha$ for every $alpha in Delta$ and $H_(tilde(alpha), 1)$ and the corresponding reflections to be $S_a := {s_alpha, alpha in Delta} cup {s_(tilde(alpha), 1)}$. The walls of $w A_circle.small$ can be defined as images of these hyperplanes under $w$ for any $w in W_a$.
]

#prop[
  The group $W_a$ permutes the collection $cal(A)$ of all alcoves transitively, and is generated by the set $S_a$ of reflections with respect to the walls of the alcove $A_circle.small$.
][]

#defn(name: [Length])[
  $S_a$ generates $W_a$ so we can define the *length* $ell(w)$ of an element $w in W_a$ to be the smallest $r$ for which $w$ is a product of $r$ elements of $S_a$.
]

== Counting Hyperplanes

#rem[
  Define $cal(L) (w) := {H in cal(H) | H "separates" A_circle.small "and" w A_circle.small}$ and define $n(w) = abs(cal(L) (w))$.

  The restriction of $n$ to $W_a$ (instead of its domain of definition $hat(W_a)$) is equivalent to $ell$.
]

#prop[
  Let $w in hat(W_a)$ and fix $s in S_a$.
  1. $H_s$ belongs to exactly one of the set $cal(L) (w^(-1))$, $cal(L) (s w^(-1))$.
  2. $s(cal(L) (w^(-1)) \\ {H_s}) = cal(L) (s w^(-1)) \\ {H_s}$.
  3. $n(w s) = n(w) - 1$ if $H_s in cal(L) (w^(-1))$, and $n(w s) = n(w) + 1$ otherwise.
][]

#cor[
  For any $w in W_a$, we have $n(w) lt.eq ell(w)$.
][]

== Simple Transitivity

#lem[
  If $w eq.not 1$ in $W_a$ has a reduced expression $w = s_1 dots.h.c s_r$, with $s_i in S_a$, then (setting $H_i := H_(s_i)$) the hyperplanes $
    H_1, s_1 H_2, s_1 s_2 H_3, ..., s_1 dots.h.c s_(r - 1) H_r
  $ are all distinct.
][]

#thm[
  1. Let $w eq.not 1$ in $W_a$ have a reduced expression $w = s_1 dots.h.c s_r$. Then we have $
    cal(L)
      &= {H_1, s_1 H_2, s_1 s_2 H_3, ..., s_1 dots.h.c s_(r - 1) H_r}.
  $ Moreover, these $r$ hyperplanes are all distinct.
  2. The function $n$ on $W_a$ coincides with the length function $ell$.
  3. The group $W_a$ acts simply transitively on $cal(A)$.
][]

== Exchange Condition

#thm(name: [Exchange Condition])[
  Let $w in W_a$ have a reduced expression $w = s_1 dots.h.c s_r$, with $s_i in S_a$. If $ell(w s) < ell(w)$ for $s in S_a$, then there exists an index $1 lt.eq i lt.eq r$ for which $w s = s_1 dots.h.c hat(s_i) dots.h.c s_r$.
][]

#thm[
  The pair $(W_a, S_a)$ is a Coxeter system.
][]

== Coxeter graphs and extended Dynkin diagrams

== Fundamental domain

#thm[
  The closure of $A_circle.small$ is a fundamental domain for the action of $W_a$ on $V$.
][]

== A formula for the order of $W$

#thm[
  If $W$ is an irreducible Weyl group of rank $n$, then $
    ord(W)
      &= n! c_1 dots.h.c c_n f
  $ where $f$ is the index of connection and $c_i$ are the coefficients of the highest root where $
    tilde(alpha)
      &= sum c_i alpha_i
  $ for $alpha_i in Delta$.
][]

= Coxeter Groups

== Coxeter systems

#defn(name: [Coxeter system])[
  A *Coxeter system* to be a pair $(W, S)$ consisting of a group $W$ and a set of generators $S subset.eq W$ subject only to relations of the form $(s s')^(m(s, s')) = 1$ where $m(s, s) = 1$ and $m(s, s') = m(s', s) gt.eq 2$ for $s eq.not s'$ in $S$. If no relation exists between $s$ and $s'$ we have $m(s, s') = infty$.

  We call $abs(S)$ the *rank* of $(W, S)$. $W$ is referred to as the *Coxeter group*. It is typically assumed that $S$ is finite but it is not required. A *Coxeter graph* $Gamma$ is drawn by treating $S$ as the set of vertices and a weighted edge with the weight $m(s, s')$ if $m(s, s') gt.eq 3$.
]

#prop[
  There is a unique epimorphism $epsilon: W -> {1, -1}$ sending each generator $s in S$ to $-1$. In particular, each $s$ has order $2$ in $W$.
][]

== Length function

#defn(name: [Length])[
  A *length* of $w in W$ as the number of $s_i in S$ such that $w = s_1 dots.h.c s_r$ is a *reduced expression*. Some of the following properties hold:
  1. $ell(w) = ell(w^(-1))$
  2. $ell(w) = 1$ if and only if $w in S$
  3. $ell(w w') lt.eq ell(w) + ell(w')$
  4. $ell(w w') gt.eq ell(w) - ell(w')$
  5. $ell(w) - 1 lt.eq ell(w s) lt.eq ell(w) + 1$
  Also note that $ell(1) = 0$ by convention.
]

#prop[
  The homomorphism $epsilon: W -> {pm 1}$ is given by $epsilon(w) = (-1)^ell(w)$. As a result, $ell(w s) = ell(w) pm 1$, for all $s in S, w in W$, and similarly for $ell(s w)$.
][
  Let $w = s_1 dots.h.c s_r$ be a reduced expression. Then $epsilon(w) = epsilon(s_1) dots.h.c epsilon(s_r) = (-1)^ell(w)$.
]

== Geometric representation of $W$

#defn(name: [Geometric representation of $W$])[
  Choose a basis of $V$ over $RR$ in one-to-one correspondence with $S$, the impose geometry using a symmetric bilinear form $B$ on $V$ by $B(alpha_s, alpha_(s')) = - cos(pi/(m(s, s')))$. $H_s$, orthogonal to $alpha_s$ relative to $B$, is complementary to the line $RR alpha_s$.

  We can define reflections $sigma_s lambda = lambda - 2 B(alpha_s, lambda) alpha_s$. Note $B(sigma_s lambda, sigma_s mu) = B(lambda, mu)$.
]

#prop[
  There is a unique homomorphism $sigma:W -> GL(V)$ sending $s$ to $sigma_s$, and the group $sigma(W)$ preserves the form $B$ on $V$. Moreover, for each pair $s, s' in S$, the order of $s s'$ in $W$ is precisely $m(s, s')$.
][]

== Positive and negative roots

#defn(name: [Root System])[
  Let the *root system* $Phi$ of $W$ consisting of all vectors $w(alpha_s) := sigma(w) (alpha_s)$ for all $w in W$ and $s in S$. These are unit vectors since $W$ preserves the form $B$ on $V$.

  $alpha$ is *positive* (resp. *negative*) if it is a linear combination of ${alpha_s | s in S}$ with all nonnegative (resp. nonpositive) weights.
]

#defn(name: [Parabolic Subgroup])[
  A *parabolic subgroup* $W_I$ of $W$ is the subgroup generated by a subset $I subset.eq S$.
]

#thm[
  Let $w in W$ and $s in S$. If $ell(w s) > ell(w)$, then $w(alpha_s) > 0$. If $ell(w s) < ell(w)$, then $w(alpha_s) < 0$.
][]

#cor[
  The representation $sigma:W -> GL(V)$ is faithful.
][
  Let $w in ker(sigma)$. If $w eq.not 1$, there exists $s in S$ for which $ell(w s) < ell(w)$. The previous theorem states that $w(alpha_s) < 0$. But $w(alpha_s) = alpha_s > 0$, which is a contradiction.
]

== Parabolic subgroups

#thm[
  1. For each subset $I$ of $S$, the pair $(W_I, I)$ with the given values $m(s, s')$ is a Coxeter system.
  2. Let $I subset.eq S$. If $w = s_1 dots.h.c s_r$ is a reduced expression, and $w in W_I$, then all $s_i in I$. In particular, the function $ell$ agrees with $ell_I$ on $W_I$, and $W_I cap S = I$.
  3. The assignment $I |-> W_I$ defines the lattice isomorphism between the collection of subsets of $S$ and the collection of subgroups $W_I$ of $W$.
  4. $S$ is a minimal generating set for $W$.
][]

== Geometric interpretation of the length function

#prop[
  1. If $s in S$, then $s$ sends $alpha_s$ to its negative, but permutes the remaining positive roots.
  2. For any $w in W$, $ell(w)$ equals the number of positive roots sent by $w$ to negative roots.
][]

== Roots and reflections

#rem[
  If we let $alpha = w(alpha_s)$ for some $w in W, s in S$ it can by shown $w s w^(-1) (lambda) = lambda - 2 B(lambda, alpha) alpha$ such that the transformation only relies on $alpha$. We denote $w s w^(-1) = s_alpha$.

  The correspondence of $alpha |-> s_alpha$ is bijective (for $alpha in Pi := Phi^+$)
]

#lem[
  If $alpha, beta in Phi$ and $beta = w(alpha)$ for some $w in W$, then $w s_alpha w^(-1) = s_beta$.
][]

#prop[
  Let $w in W, alpha in Pi$. Then $ell(w s_alpha) > ell(w)$ if and only if $w(alpha) > 0$.
][]

== Strong Exchange Condition

#thm(name: [Strong Exchange Condition])[
  Let $w = s_1 dots.h.c s_r (s_i in S)$, not necessarily a reduced expression. Suppose a reflection $t in T$ satisfies $ell(w t) < ell(w)$. Then there is an index $i$ for which $w t = s dots.h.c hat(s_i) dots.h.c s_r$. If the expression $w$ is reduced, then $i$ is unique. Here $T = cup.big_(w in W) w S w^(-1)$ is the set of all reflections.
][]

#cor(name: [Deletion Condition])[
  1. Suppose $w = s_1 dots.h.c s_r (s_i in S)$, with $ell(w) < r$. Then there exist indices $i < j$ for which $w = s_1 dots.h.c hat(s_i) dots.h.c hat(s_j) dots.h.c s_r$.
  2. If $w = s_1 dots.h.c s_r$, then a reduced expression for $w$ may be obtained by omitting certain $s_i$ (an even number).
][]

== Bruhat ordering

#defn(name: [Bruhat ordering])[
  Write $w' -> w$ if $w = w' t$ for some $t in T$ with $ell(w) > ell(w')$. Define $w' < w$ if there is a sequence $
    w' = w_0 -> w_1 -> ... -> w_m = w.
  $ $w' lt.eq w$ is a partial ordering of $W$ with $1$ as the unique minimal element. This ordering is called the *Bruhat ordering*.

  If we restrict $t in s$ we get a *weak ordering* which has a one-sided nature (the Bruhat ordering can be written using either left or right multiplication by $t$).
]

#prop[
  Let $w' lt.eq w$ and $s in S$. Then either $w's lt.eq w$ or else $w' s lt.eq w s$ (or both).
][]

== Subexpressions

#defn(name: [Subexpressions])[
  Given a reduced expression $w = s_1 dots.h.c s_r$ we have *subexpressions* of the form $s_(i_1) dots.h.c s_(i_q)$ where $1 lt.eq i_1 < ... < i_q lt.eq r$. The subexpression is formally the $q$-tuple obtained by selecting generators from the tuple for the reduced expression of $w$.
]

#thm[
  Let $w = s_1 dots.h.c s_r$ be a fixed, but arbitrary, reduced expression for $w$. Then $w' lt.eq w$ if and only if $w'$ can be obtained as a subexpression of this reduced expression.
][]

#cor[
  If $I subset.eq S$, the Bruhat ordering of $W$ agrees on $W_I$ with the Bruhat ordering of the Coxeter group $W_I$.
][]

== Intervals in the Bruhat ordering

#lem[
  Let $w' < w$, with $ell(w) = ell(w') + 1$. Suppose there exists $s in S$ for which $w' < w's$ and $w's eq.not w$. Then both $w < w s$ and $w's < w s$.
][]

#prop[
  Let $w' < w$. Then there exist $w_0, ..., w_m in W$ such that $w' = w_0 < ... < w_m = w$, and $ell(w_i) = ell(w_(i - 1)) + 1$ for $1 lt.eq i lt.eq m$.
][]

== Poincare series

#rem[
  $
    W^I
      &:= {w in W | ell(w s) > ell(w) "for all" s in I}.
  $
]

#defn(name: [Poincare series of $W$])[
  The *Poincare series* of $W$ is given by $
    W(t)
      &= sum_(n gt.eq 0) "Card"({w in W | ell(w) = n}) t^n.
  $
]

#prop[
  1. In the field of formal power series in $t$, we have the identity $
    sum_(I subset.eq S) (-1)^I (W(t))/(W_I (t))
      &= sum_(I subset.eq S) (-1)^I W^I (t)
      &= 0
  $ unless $W$ is finite, in which case the right side equals $t^N$.
  2. $W(t)$ is an explicitly computable rational function of $t$.
][]

== Fundamental domain for $W$

#defn[
  We define a contragredient action $sigma^*: W -> GL(V^*)$ by $ip(w(f), w(lambda)) = ip(f, lambda)$ for $w in W, f in V^*, lambda in V$.

  For any $s in S$ we define the hyperplane $Z_s := {f in V^* | ip(f, alpha_s) = 0}$ together with the associated half-spaces $
    A_s
      &:= {f in V^* | ip(f, alpha_s) > 0}, quad
    A'_s
      &:= {f in V^* | ip(f, alpha_s) < 0}
      &= s(A_s).
  $ Let $C$ be the intersection of all $A_s, s in S$.
]

#lem[
  Let $s in S$ and $w in W$. Then $ell(s w) > ell(w)$ if and only if $w(C) subset.eq A_s$, whereas $ell(s w) < ell(w)$ if and only if $w(C) subset.eq A'_s$
][]

#thm[
  1. Let $w in W$ and $I, J subset.eq S$. If $w(C_I) cap C_J eq.not emptyset$, then $I = J$ and $w in W_I$, so $w(C_I) = C_I$. In particular, $W_I$ is the precise stabilizer in $W$ of each point of $C_I$, and $cal(C)$ is a partition of $U$.
  2. $D$ is a fundamental domain for the action of $W$ on $U$: the $W$-orbit of each point of $U$ meets $D$ in exactly one point.
  3. The cone $U$ is convex, and every closed line segment in $U$ meets just finitely many of the sets in the family $cal(C)$.
][]
